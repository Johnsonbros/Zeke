/**
 * ZEKE Backend Signature Verification Middleware
 * 
 * Add this code to your ZEKE backend (zekeai.replit.app) to verify
 * signed requests from the mobile app proxy.
 * 
 * Installation:
 * 1. Copy this code to your ZEKE backend server
 * 2. Set the ZEKE_SHARED_SECRET environment variable (same value on both servers)
 * 3. Add the middleware to your Express routes
 * 
 * SIGNATURE FORMAT: timestamp.nonce.METHOD.path.bodyHash
 * - timestamp: Unix timestamp (seconds or milliseconds)
 * - nonce: Random string for replay protection (can be empty string)
 * - METHOD: HTTP method uppercase (GET, POST, etc.)
 * - path: Request path including leading slash (e.g., /api/tasks)
 * - bodyHash: SHA-256 hash of request body (or hash of empty string for no body)
 * - Delimiter: . (dot)
 */

import crypto from "crypto";
import type { Request, Response, NextFunction } from "express";

const SHARED_SECRET = process.env.ZEKE_SHARED_SECRET || "";
const TIMESTAMP_TOLERANCE_MS = 5 * 60 * 1000; // 5 minutes

// Nonce cache to prevent replay attacks
const usedNonces = new Map<string, number>();

// Clean up old nonces every minute
setInterval(() => {
  const now = Date.now();
  for (const [nonce, timestamp] of usedNonces.entries()) {
    if (now - timestamp > TIMESTAMP_TOLERANCE_MS * 2) {
      usedNonces.delete(nonce);
    }
  }
}, 60 * 1000);

function computeBodyHash(body: unknown): string {
  const bodyStr = body && Object.keys(body as object).length > 0 
    ? JSON.stringify(body) 
    : '';
  return crypto.createHash('sha256').update(bodyStr).digest('hex');
}

function safeCompare(a: string, b: string): boolean {
  try {
    const bufA = Buffer.from(a, 'hex');
    const bufB = Buffer.from(b, 'hex');
    if (bufA.length !== bufB.length) return false;
    return crypto.timingSafeEqual(bufA, bufB);
  } catch {
    return false;
  }
}

export function verifyZekeSignature(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // Skip verification if secret not configured
  if (!SHARED_SECRET || SHARED_SECRET.length < 32) {
    console.warn("[ZEKE Security] Shared secret not configured, skipping verification");
    return next();
  }

  const timestamp = req.headers["x-zeke-timestamp"] as string;
  const nonce = req.headers["x-zeke-nonce"] as string;
  const signature = req.headers["x-zeke-signature"] as string;
  const requestId = req.headers["x-zeke-request-id"] as string;

  // If no security headers, allow unsigned requests (for backwards compatibility)
  if (!timestamp && !signature) {
    console.log(`[ZEKE Security] Unsigned request to ${req.path}`);
    return next();
  }

  // If some headers present, signature and timestamp must be present
  if (!timestamp || !signature) {
    console.warn(`[ZEKE Security] Missing security headers [${requestId}]`);
    res.status(401).json({ error: "Missing security headers" });
    return;
  }

  // Handle both Unix seconds (10 digits) and Unix milliseconds (13 digits)
  const ts = parseInt(timestamp, 10);
  const timestampMs = ts.toString().length <= 10 ? ts * 1000 : ts;
  const now = Date.now();
  
  if (isNaN(ts) || Math.abs(now - timestampMs) > TIMESTAMP_TOLERANCE_MS) {
    console.warn(`[ZEKE Security] Timestamp expired or invalid [${requestId}]`);
    res.status(401).json({ error: "Timestamp expired or invalid" });
    return;
  }

  // Check for replay attack (only if nonce provided)
  const effectiveNonce = nonce || '';
  if (effectiveNonce && usedNonces.has(effectiveNonce)) {
    console.warn(`[ZEKE Security] Replay attack detected [${requestId}]`);
    res.status(401).json({ error: "Nonce already used (replay attack detected)" });
    return;
  }

  // Compute body hash
  const bodyHash = computeBodyHash(req.body);

  // Reconstruct the signature payload
  // Format: timestamp.nonce.METHOD.path.bodyHash
  const payload = `${timestamp}.${effectiveNonce}.${req.method.toUpperCase()}.${req.path}.${bodyHash}`;

  const expectedSignature = crypto
    .createHmac("sha256", SHARED_SECRET)
    .update(payload)
    .digest("hex");

  // Use timing-safe comparison
  const isValid = safeCompare(signature, expectedSignature);

  if (!isValid) {
    console.warn(`[ZEKE Security] Invalid signature [${requestId}]`);
    console.log(`[ZEKE Security] Payload format: timestamp.nonce.METHOD.path.bodyHash`);
    console.log(`[ZEKE Security] Payload used: ${payload}`);
    console.log(`[ZEKE Security] Received: ${signature.substring(0, 16)}...`);
    console.log(`[ZEKE Security] Expected: ${expectedSignature.substring(0, 16)}...`);
    res.status(401).json({ error: "Invalid signature" });
    return;
  }

  // Mark nonce as used (only if nonce provided)
  if (effectiveNonce) {
    usedNonces.set(effectiveNonce, now);
  }

  console.log(`[ZEKE Security] Verified request [${requestId}]`);
  next();
}

/**
 * Usage example:
 * 
 * import { verifyZekeSignature } from "./zeke-backend-verification";
 * 
 * // Apply to all /api routes
 * app.use("/api", verifyZekeSignature);
 * 
 * // Or apply to specific routes
 * app.get("/api/tasks", verifyZekeSignature, (req, res) => { ... });
 * 
 * SIGNATURE FORMAT SUMMARY:
 * - Payload: timestamp.nonce.METHOD.path.bodyHash
 * - Delimiter: . (dot)
 * - bodyHash: SHA-256 of JSON.stringify(body) or empty string for no body
 * - Empty body hash: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
 */
