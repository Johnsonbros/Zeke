"""
Triage ticket generator for failure diagnostics.

Creates TICKET-<run_id>.md files with:
- Stack trace
- Last 20 decisions
- Redacted inputs
- Failure hypothesis
"""

import os
import traceback
import threading
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any

from python_agents.guards.tool_policy import get_policy_validator


class FailureType(Enum):
    """Types of failures that trigger triage tickets."""
    RUN_BUDGET_EXCEEDED = "run_budget_exceeded"
    CIRCUIT_BREAKER_OPEN = "circuit_breaker_open"
    UNHANDLED_EXCEPTION = "unhandled_exception"
    TOOL_POLICY_VIOLATION = "tool_policy_violation"
    API_ERROR = "api_error"
    TIMEOUT = "timeout"


@dataclass
class Decision:
    """A single agent decision for the decision log."""
    timestamp: str
    agent_id: str
    action: str
    tool_name: str | None = None
    result: str | None = None
    
    def to_markdown(self) -> str:
        """Format decision as markdown list item."""
        tool_info = f" â†’ `{self.tool_name}`" if self.tool_name else ""
        result_info = f" ({self.result})" if self.result else ""
        return f"- [{self.timestamp}] **{self.agent_id}**: {self.action}{tool_info}{result_info}"


@dataclass
class TriageTicket:
    """Data structure for a triage ticket."""
    run_id: str
    failure_type: FailureType
    timestamp: str
    stack_trace: str
    decisions: list[Decision]
    redacted_inputs: dict[str, Any]
    hypothesis: str
    additional_context: dict[str, Any] = field(default_factory=dict)
    
    def to_markdown(self) -> str:
        """Generate the full markdown ticket content."""
        lines = [
            f"# Triage Ticket: {self.run_id}",
            "",
            f"**Created:** {self.timestamp}",
            f"**Failure Type:** `{self.failure_type.value}`",
            "",
            "---",
            "",
            "## Hypothesis",
            "",
            self.hypothesis,
            "",
            "---",
            "",
            "## Stack Trace",
            "",
            "```",
            self.stack_trace,
            "```",
            "",
            "---",
            "",
            "## Last 20 Decisions",
            "",
        ]
        
        if self.decisions:
            for decision in self.decisions[-20:]:
                lines.append(decision.to_markdown())
        else:
            lines.append("_No decisions recorded_")
        
        lines.extend([
            "",
            "---",
            "",
            "## Redacted Inputs",
            "",
            "```json",
        ])
        
        import json
        lines.append(json.dumps(self.redacted_inputs, indent=2, default=str))
        
        lines.extend([
            "```",
            "",
        ])
        
        if self.additional_context:
            lines.extend([
                "---",
                "",
                "## Additional Context",
                "",
                "```json",
                json.dumps(self.additional_context, indent=2, default=str),
                "```",
                "",
            ])
        
        lines.extend([
            "---",
            "",
            "_Generated by ZEKE Triage System_",
        ])
        
        return "\n".join(lines)


class TriageTicketGenerator:
    """
    Generates triage tickets for failure diagnostics.
    
    Creates markdown files in the triage directory with:
    - Stack trace
    - Last 20 agent decisions
    - Redacted inputs (PII removed)
    - Auto-generated hypothesis about failure cause
    """
    
    def __init__(
        self,
        triage_dir: str | Path = "triage",
        max_decisions: int = 20,
    ):
        """
        Initialize the triage generator.
        
        Args:
            triage_dir: Directory to write triage tickets
            max_decisions: Maximum decisions to include (default 20)
        """
        self.triage_dir = Path(triage_dir)
        self.max_decisions = max_decisions
        self._lock = threading.Lock()
        
        self.triage_dir.mkdir(parents=True, exist_ok=True)
    
    def _generate_hypothesis(
        self,
        failure_type: FailureType,
        stack_trace: str,
        decisions: list[Decision],
        context: dict[str, Any],
    ) -> str:
        """
        Generate a hypothesis about the failure cause.
        
        Uses heuristics based on failure type and context.
        """
        if failure_type == FailureType.RUN_BUDGET_EXCEEDED:
            tool_calls = context.get("tool_calls_used", 0)
            limit = context.get("tool_calls_limit", 25)
            elapsed = context.get("elapsed_seconds", 0)
            timeout = context.get("timeout_seconds", 120)
            
            if elapsed >= timeout:
                return (
                    f"**Timeout exceeded**: The run took {elapsed:.1f}s, exceeding the "
                    f"{timeout}s timeout. This suggests either slow API responses, "
                    f"complex processing, or an infinite loop in the agent logic."
                )
            else:
                tools_called = context.get("tools_called", [])
                tool_summary = ", ".join(f"`{t}`" for t in tools_called[-5:]) if tools_called else "unknown"
                return (
                    f"**Tool call limit exceeded**: Used {tool_calls}/{limit} tool calls. "
                    f"Recent tools: {tool_summary}. The agent may be stuck in a retry loop "
                    f"or the task requires more steps than the budget allows."
                )
        
        elif failure_type == FailureType.CIRCUIT_BREAKER_OPEN:
            service = context.get("service", "unknown")
            failure_count = context.get("failure_count", 0)
            return (
                f"**Circuit breaker open for `{service}`**: {failure_count} consecutive "
                f"failures triggered the circuit breaker. The external service may be "
                f"experiencing an outage or rate limiting."
            )
        
        elif failure_type == FailureType.TOOL_POLICY_VIOLATION:
            tool_name = context.get("tool_name", "unknown")
            violation_type = context.get("violation_type", "unknown")
            return (
                f"**Tool policy violation**: Tool `{tool_name}` was blocked due to "
                f"`{violation_type}`. This may indicate an attempt to use a restricted "
                f"tool or invalid input parameters."
            )
        
        elif failure_type == FailureType.API_ERROR:
            service = context.get("service", "unknown")
            status_code = context.get("status_code", "unknown")
            return (
                f"**API error from `{service}`**: Received status code {status_code}. "
                f"Check API credentials, rate limits, and service availability."
            )
        
        elif failure_type == FailureType.TIMEOUT:
            operation = context.get("operation", "unknown")
            timeout = context.get("timeout", 0)
            return (
                f"**Operation timeout**: `{operation}` exceeded {timeout}s timeout. "
                f"The operation may be too slow or blocked on external resources."
            )
        
        else:
            exception_type = ""
            if stack_trace:
                lines = stack_trace.strip().split("\n")
                if lines:
                    exception_type = lines[-1].split(":")[0] if ":" in lines[-1] else lines[-1]
            
            return (
                f"**Unhandled exception**: `{exception_type}`. Review the stack trace "
                f"for the root cause. This may be a bug in the agent code or an "
                f"unexpected state in the system."
            )
    
    def _redact_inputs(self, inputs: dict[str, Any]) -> dict[str, Any]:
        """Redact sensitive information from inputs."""
        validator = get_policy_validator()
        return validator.redact_output("_global", inputs)
    
    def create_ticket(
        self,
        run_id: str,
        failure_type: FailureType,
        exception: Exception | None = None,
        decisions: list[Decision] | None = None,
        inputs: dict[str, Any] | None = None,
        context: dict[str, Any] | None = None,
    ) -> Path:
        """
        Create a triage ticket for a failure.
        
        Args:
            run_id: Unique identifier for the run
            failure_type: Type of failure
            exception: The exception that caused the failure (if any)
            decisions: List of agent decisions leading up to failure
            inputs: Raw inputs (will be redacted)
            context: Additional context about the failure
            
        Returns:
            Path to the created ticket file
        """
        timestamp = datetime.now().isoformat()
        
        if exception:
            stack_trace = "".join(traceback.format_exception(
                type(exception), exception, exception.__traceback__
            ))
        else:
            stack_trace = "No exception provided"
        
        decisions = decisions or []
        decisions = decisions[-self.max_decisions:]
        
        redacted_inputs = self._redact_inputs(inputs or {})
        
        hypothesis = self._generate_hypothesis(
            failure_type,
            stack_trace,
            decisions,
            context or {},
        )
        
        ticket = TriageTicket(
            run_id=run_id,
            failure_type=failure_type,
            timestamp=timestamp,
            stack_trace=stack_trace,
            decisions=decisions,
            redacted_inputs=redacted_inputs,
            hypothesis=hypothesis,
            additional_context=context or {},
        )
        
        filename = f"TICKET-{run_id}.md"
        filepath = self.triage_dir / filename
        
        with self._lock:
            filepath.write_text(ticket.to_markdown())
        
        return filepath
    
    def get_pending_tickets(self) -> list[Path]:
        """Get all pending triage tickets."""
        return sorted(self.triage_dir.glob("TICKET-*.md"))
    
    def archive_ticket(self, ticket_path: Path) -> Path:
        """Move a ticket to the archive subdirectory."""
        archive_dir = self.triage_dir / "archive"
        archive_dir.mkdir(exist_ok=True)
        
        dest = archive_dir / ticket_path.name
        ticket_path.rename(dest)
        return dest


_default_generator: TriageTicketGenerator | None = None
_generator_lock = threading.Lock()


def get_triage_generator(
    triage_dir: str | Path = "triage",
    **kwargs,
) -> TriageTicketGenerator:
    """Get or create the default triage generator singleton."""
    global _default_generator
    
    with _generator_lock:
        if _default_generator is None:
            _default_generator = TriageTicketGenerator(
                triage_dir=triage_dir,
                **kwargs,
            )
        return _default_generator


def create_triage_ticket(
    run_id: str,
    failure_type: FailureType,
    exception: Exception | None = None,
    decisions: list[Decision] | None = None,
    inputs: dict[str, Any] | None = None,
    context: dict[str, Any] | None = None,
) -> Path:
    """
    Convenience function to create a triage ticket using the default generator.
    
    Args:
        run_id: Unique identifier for the run
        failure_type: Type of failure
        exception: The exception that caused the failure
        decisions: List of agent decisions
        inputs: Raw inputs (will be redacted)
        context: Additional context
        
    Returns:
        Path to the created ticket file
    """
    generator = get_triage_generator()
    return generator.create_ticket(
        run_id=run_id,
        failure_type=failure_type,
        exception=exception,
        decisions=decisions,
        inputs=inputs,
        context=context,
    )
